# 输入 url 之后发生的事情

## 请求资源

## 渲染（基于 webkit 引擎）

1.因为服务器传输过来的是 0/1 字节数据所以浏览器转换成字符串，也就是我们写的代码（字节数据转字符串）  

2.将字符串通过词法分析转换成标记，这一步叫标记化  

3.将生成的标记转化为 Node，然后这些 Node 会根据不同 Node 之前的联系构建为 DOM 树  

4.将 CSS 文件转换为 CSSOM 树（这一步的转换过程和 HTML 文件极其类似，这一步就可以涉及到浏览器递归 CSSOM 树的资源消耗，详情参考 14.md）  

5.将生成的 DOM 树和 CSSOM 树组合为渲染树（渲染树只会包括需要显示的节点和对应节点的样式信息）  

6.根据渲染树进行布局（也可以叫做回流），然后调用 GPU 生成图层显示在屏幕上
# 
# 为什么操作DOM慢
因为DOM是属于渲染引擎中的东西，而JS又是JS引擎的东西，当我们通过JS操作DOM的时候，这个时候就设计了两个线程之间的通信，那么肯定会带来性能上的损耗。操作dom多的话线程直接通信就多，而且操作DOM可能会带来重绘回流的情况，所以也就导致了性能上面的问题。
## 经典面试题：插入几万个 DOM，如何实现页面不卡顿？
实现方案，虚拟滚动
# 什么情况会阻塞渲染
首先渲染的前提是生成渲染树，所以HTML+CSS肯定会阻塞渲染。想要渲染快，降低渲染文件大小，并且扁平层级，优化选择器必不可少。  
然后script标签解析也会暂停构建DOM，完成后才会从暂停的地方重新开始。所以首屏不应该就加载JS文件或者给script标签加上defer（异步加载，html解析完执行）或者async（异步下载，同步解析）属性
# 重绘（Repaint）和回流（Reflow）
## 重绘
重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘  
## 回流
回流是布局或者几何属性需要改变就称为回流
## 
1. 重绘不一定发生回流，回流必定发生重绘，回流成本更高  
重绘和回流和EventLoop有关  
1. 当 Eventloop 执行完 Microtasks 后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。  
2. 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。  
3. 判断是否触发了 media query  
4. 更新动画并且发送事件  
5. 判断是否有全屏操作事件  
6. 执行 requestAnimationFrame 回调  
7. 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好  
8. 更新界面  
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。  
## 减少重绘和回流
用transform代替top、用visibility代替dispaly:none、减少获取offsetTop（会导致回流，因为要去获取正确的值）、不要用table（一个小改动都会导致table重新布局）、动画实现速度选择（速度越快回流次数越多，可以选择使用requestAnimationFrame）、css选择符避免节点层级过多、将频繁重绘或者回流的节点设置为图层（图层会阻止该节点的渲染行为影响其它节点）